/**
 * Область видимости в JavaScript и «поднятие» переменных и объявлений функций.
 */

var foo = 1;

function bar() {

  if (!foo) {
    var foo = 10;
  }

  alert(foo);
}

bar();

//### Область видимости в JavaScript.

// JavaScript реализует область видимости на уровне функций.
// Т.е. блоки кода, типа if, for, while и т.д. не создают новую область видимости.
// Только функции создают новые области видимости.

// ### Объявления, именование и «поднятие» (hoisting) переменных и функций
// В JavaScript существует четыре основных способа появления идентификатора
// (имя переменной/ф-ции) в области видимости:
//   1. Внутренние механизмы языка: например, во всех областях видимости
//      доступны this и arguments.
//   2. Формальные параметры: у функций могут быть именованные формальные
//      параметры, область видимости которых ограничена телом функции.
//   3. Объявления функций: объявленные в виде function foo() {}.
//   4. Объявления переменных: например, var foo;.

// Ф-я foo:
function foo() {
  bar();
  var x = 1;
}
// на самом деле интерпретируется так:
function foo() {
  var x;
  bar();
  x = 1;
}

// Не важно, будет ли вообще выполнена строка, в которой происходит объявление.
// Переменные/ф-ции (Function declaration) поднимутся всегда:
// Следующая ф-я:
function foo() {
  if (false) {
    var x = 1;
  }
  return;
  var y = 1;
}
// Будет интерпретирована следующим образом:
function foo() {
  var x, y;
  if (false) {
    x = 1;
  }
  return;
  y = 1;
}
//!!! Присваивание значений переменным не поднимается вместе с их объявлением.
// В случае с функциями, поднимается вся функция целиком.
function test() {
  foo(); // TypeError "foo is not a function" так как foo = undefined при поднятии и до момента присваивания значения.
  bar(); // "this will run!"
  var foo = function () { // функциональное выражение, присвоенное локальной переменной 'foo'
    alert("this won't run!");
  }
  function bar() { // объявление функции с именем 'bar'
    alert("this will run!");
  }
}
test();


// ### Разрешение имён.
// Самый важный особый случай, который стоит иметь в виду - это порядок разрешения имён.
// Вспомните, есть четыре способа появления идентификаторов в области видимости.
// Именно в том порядке, в котором они были указанны, и происходит разрешение имён.

// В общем случае, если имя уже определено, оно никогда не будет переопределено другой сущностью
// с таким же именем. То есть объявление функции имеет приоритет над объявлениями переменной с таким же
// именем. Но это совсем не означает, что присваивание переменной значение не заменит функцию,
// просто её определение будет проигнорировано.

// Есть несколько исключений:
//   - Встроенный идентификатор arguments ведёт себя странно. Он как будто объявляется сразу после
//     формальных аргументов функции и перед объявлениями функций. Это означает, что если у функции
//     есть формальный аргумент arguments, у него будет приоритет над встроенным, даже если его не
//     передадут при вызове функции. Это плохая особенность JavaScript. Не используйте формальный аргумент
//     с именем arguments.
//   - Если вы попробуете использовать this в качестве идентификатора, произойдёт ошибка SyntaxError.
//     Это хорошая особенность.
//   - Если в списке формальных параметров функции несколько из них имеют одинаковое имя, тот параметр,
//     который упоминается последним, имеет приоритет. Даже если его не передали при вызове функции.







