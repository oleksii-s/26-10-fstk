/**
 * Замыкания, работа функции изнутри.
 *
 * В этом разделе мы продолжим рассматривать, как работают переменные, и,
 * как следствие, познакомимся с замыканиями.
 */

//### Лексическое окружение (LexicalEnvironment).

// При запуске функция создает объект LexicalEnvironment,
// записывает туда аргументы, функции и переменные.
// Все переменные внутри функции – это свойства специального внутреннего
// объекта LexicalEnvironment, который создаётся при её запуске.

// При вызове функции:
// 1. Инициализация (интерпретатор создает пустой объект LexicalEnvironment и заполняет его).
// 2. Выполнение функции (присвоение локальных переменных).
// 3. В конце выполнения функции объект с переменными обычно выбрасывается и память очищается.

function sayHello(name) {
  // LexicalEnvironment = { name: 'Вася', phrase: undefined }
  var phrase = "Привет, " + name;

  // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}
  alert( phrase );
}

sayHello('Вася');


// ### Доступ ко внешним переменным.

// - Каждая функция при создании получает ссылку [[Scope]] на объект с переменными,
//    в контексте которого была создана.
// - При запуске функции создаётся новый объект с переменными LexicalEnvironment.
//    Он получает ссылку на внешний объект переменных из [[Scope]].
// - При поиске переменных он осуществляется сначала в текущем объекте переменных,
//    а потом – по этой ссылке.

var userName = "Вася";

function sayHi() {
  // sayHi.[[Scope]] = window
  alert( userName ); // "Вася"
}


// ### Всегда текущее значение.
// Значение переменной из внешней области берётся всегда текущее.
// Оно может быть уже не то, что было на момент создания функции.
var phrase = 'Привет';

function sayHi(name) {
  alert(phrase + ', ' + name);
}

sayHi('Вася');  // Привет, Вася (*)

phrase = 'Пока';

sayHi('Вася'); // Пока, Вася (**)


// ### Вложенные функции.
// Вложенные функции получают [[Scope]] так же, как и глобальные.
function sayHiBye(firstName, lastName) {

  alert( "Привет, " + getFullName() );
  alert( "Пока, " + getFullName() );

  function getFullName() {
    return firstName + " " + lastName;
  }

}

sayHiBye("Вася", "Пупкин"); // Привет, Вася Пупкин ; Пока, Вася Пупкин


// ### Возврат функции.
// Пример ф-ции счетчика, возвращающую другую (вложенную ф-цию):
function makeCounter() {
  var currentCount = 1;

  return function() {
    return currentCount++;
  };
}
// Создадим новый счетчик.
var counter = makeCounter(); // создаётся LexicalEnvironment для переменных текущего вызова makeCounter().

// Вызовем счетчик.
// каждый вызов увеличивает счётчик и возвращает результат
alert( counter() ); // 1
alert( counter() ); // 2
alert( counter() ); // 3

// Создадим другой счётчик, он будет независим от первого
var counter2 = makeCounter();
alert( counter2() ); // 1
// В результате мы получили два независимых счётчика counter и counter2,
// каждый из которых незаметным снаружи образом сохраняет текущее количество вызовов
// во внешней переменной currentCount, которая у каждого счётчика своя (в своем LexicalEnvironment).


// ### Свойства функции.
function f() {}

f.test = 5;
alert( f.test );


//### Итого:
//  Замыкание - это своего рода передача нескольких локальных переменных таким образом,
//  чтобы они были доступны в функции, которая может быть «отдана» за пределы текущей области видимости.
function a() {
  var x = 5;
  return function() { return x; }
}

