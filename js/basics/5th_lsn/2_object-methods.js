/**
 * Объекты – методы, this.
 * Об объектах как о сущностях со своими функциями («методами»)
 */

/* ================ Методы у объектов ================= */

var user = {
  name: 'Василий',

  // метод
  sayHi: function() {
    alert( 'Привет!' );
  }

};

// Вызов
user.sayHi();

// Т.е. cвойства-функции называют «методами» объектов.

// Явное присваивание метода
user.sayBye = function() {
  alert('Пока!');
};




/* ================ Доступ к объекту через this ================= */

// Для доступа к текущему объекту из метода используется ключевое слово this.
// Значением this является объект перед «точкой», в контексте которого вызван метод
var customer = {
  name: 'Паша',

  sayHi: function() {
    alert( this.name );
  }
};

customer.sayHi(); // sayHi в контексте user

// Вместо this внутри sayHi можно было бы обратиться к объекту, используя переменную customer
// Однако, такое решение нестабильно. Если мы решим скопировать объект в другую переменную,
// например admin = customer, а в переменную customer записать что-то другое – обращение
// будет совсем не по адресу
var anonymous = {
  name: 'Donald',

  sayHi: function() {
    alert( anonymous.name ); // приведёт к ошибке
  }
};

var admin = anonymous;
user = null;

admin.sayHi(); // внутри sayHi обращение по старому имени, ошибка!

// Через this метод может не только обратиться к любому свойству объекта,
// но и передать куда-то ссылку на сам объект целиком

anonymous.passThisSomewhere = function () {
  showName(this); // передать текущий объект в showName
};

function showName(namedObj) {
  alert( namedObj.name );
}

user.sayHi(); // Donald


/* ================ Подробнее про this ================= */

// Любая функция может иметь в себе this. Совершенно неважно, объявлена ли она в объекте или отдельно от него.
// Значение this называется контекстом вызова и будет определено в момент вызова функции.

// Функция ещё не знает, каким будет this. Это выяснится при выполнении программы.
function sayHi() {
  alert( this.firstName );
}

// !!!!! Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this:
var user = { firstName: "Алексей" };
var admin = { firstName: "Админ" };

function func() {
  alert( this.firstName );
}

user.f = func;
admin.g = func;

// this равен объекту перед точкой:
user.f(); // Алексей
admin.g(); // Админ
admin['g'](); // Админ (не важно, доступ к объекту через точку или квадратные скобки)




/* ================ Значение this при вызове без контекста ================= */

// При прямом вызове (без контекста) func() this получает значение глобального объекта window
function func() {
  alert( this ); // выведет [object Window] или [object global]
}

func();

// Контекст this никак не привязан к функции, даже если она создана
// в объявлении объекта. Чтобы this передался, нужно вызвать функцию
// именно через точку (или квадратные скобки).
//
// Любой более хитрый вызов приведёт к потере контекста
var user = {
  name: "Вася",
  hi: function() { alert(this.name); },
  bye: function() { alert("Пока"); }
};

user.hi(); // Вася (простой вызов работает)

// а теперь вызовем user.hi или user.bye в зависимости от имени
(user.name == "Вася" ? user.hi : user.bye)(); // undefined