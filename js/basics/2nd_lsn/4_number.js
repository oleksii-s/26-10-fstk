/**
 * Created by Oleksii on 21.12.2016.
 */

alert( 0xFF ); // 255 в шестнадцатиричной системе

// пример научной формы: 3 с 5 нулями
alert( 3e5 ); // 300000
alert( 3e-5 ); // 0.00003


// Деление на ноль, Infinity
alert( 1 / 0 );

// NaN
alert( 0 / 0 );
alert( 'abc' / 0 );

// Значение NaN – единственное, в своем роде, которое не равно ничему, включая себя
if (NaN == NaN) alert( "==" ); // Ни один вызов
if (NaN === NaN) alert( "===" ); // не сработает

// NaN можно проверить специальной функцией isNaN(n)
var n = 0 / 0;

alert( isNaN(n) ); // true
alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12

// Любая операция с NaN возвращает NaN
alert( NaN + 1 ); // NaN

// isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
alert( isFinite(1) ); // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) ); // false

// Преобразование к числу
alert( +"12.34" ); // 12.34
alert( +"12test" ); // NaN
alert( +"  -12" ); // -12
alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
alert( +"" ); // 0, пустая строка становится нулем
alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
alert( '12.34' / "-2" ); // -6.17

// Мягкое преобразование: parseInt и parseFloat

// parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
alert(+"12px"); // NaN
// но
alert( parseInt('12px') ); // 12, ошибка на символе 'p'
alert( parseFloat('12.3.4') ); // 12.3, ошибка на второй точке
alert( parseInt('a123') ); // NaN
alert( parseInt('FF', 16) ); // 255

// Проверка на число

// можно использовать функцию isNaN(str)
// Однако, у такой проверки есть две особенности:
// - Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
// - Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает
// числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.

// Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов,
// логические и специальные значения, а также отсекает Infinity – используйте функцию isNumeric

//  как работает isNumeric
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}


// Округление

// Math.floor
// Округляет вниз
// Math.ceil
// Округляет вверх
// Math.round

// Округляет до ближайшего целого
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

// Округление до заданной точности
var n = 3.456;
alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46

// num.toFixed(precision) - return string
var n = 12.34;
alert( n.toFixed(1) ); // "12.3"
var m = 12.36;
alert( m.toFixed(1) ); // "12.4"
var l = 12.34;
alert( l.toFixed(5) ); // "12.34000", добавлены нули до 5 знаков после запятой
// return number
var n = 12.34;
alert( +n.toFixed(5) ); // 12.34

// toFixed не эквивалентен Math.round
var price = 6.35;

alert( price.toFixed(1) ); // 6.3
alert( Math.round(price * 10) / 10 ); // 6.4

// Неточные вычисления
alert( 0.1 + 0.2 == 0.3 ); //False,  0.1 + 0.2 = 0.30000000000000004
alert( 0.1 + 0.2 > 0.3 ); // true
alert( 0.1.toFixed(20) ); // 0.10000000000000000555

// это не означает, что точные вычисления для таких чисел невозможны
// есть два способа:

// 1. Сделать их целыми, сложить, а потом поделить:
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3

// 2. Сложить, а затем округлить до разумного знака после запятой.
//   Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений
var result = 0.1 + 0.2;
alert( +result.toFixed(10) ); // 0.3

// Другие математические методы http://learn.javascript.ru/number#другие-математические-методы
